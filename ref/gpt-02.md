# Laravel 應用架構分析與建議

## 引言

在大型 Laravel 專案中，常見的做法是引入 **Service 層** 和 **Repository 層**，並使用 **Data Object (DTO)** 來傳輸資料。這種分層架構可提高程式的組織性，但也帶來額外的複雜度。由於 Laravel 原生提供強大的 Eloquent ORM 及便利的方法（例如 `$request->user()`），過度抽象可能導致“過度設計”。以下將分析 Data Object 的必要性、Repository 模式是否屬於過度設計，並根據您的專案條件提出平衡的架構建議。

## Data Object 的必要性

**Data Object**（或 DTO）是一種純資料結構，用於在層與層之間傳遞資料。例如使用 Spatie 的 **laravel-data** 封裝 Eloquent 模型資料，定義哪些欄位需要傳出、哪些欄位可延遲載入或為選用。引入 Data Object 的動機與優缺點如下：

* **優點：**

  * **資料封裝與脫鉤：** 將 Eloquent 模型轉換為 Data Object，可以在業務邏輯層避免直接依賴 Eloquent。這樣即使未來更換 ORM，業務代碼影響也較小。同時，Data Object 可一次定義資料格式，在多處重用，保持介面一致。
  * **控制輸出與避免洩漏：** Data Object 可以精確定義要回傳的欄位和結構。例如可包含模型本身欄位及必要的關聯欄位，過多或敏感的欄位則不包括或標記為 Lazy/Optional。在 API 響應中，這有助於確保只返回前端需要的資料，避免直接暴露模型的隱私欄位。
  * **Lazy 加載與效能：** 將某些欄位標記為 Lazy，可以延遲計算或載入，在實際需要時才生成，避免不必要的運算。例如大型關聯關係可以設為 Optional/Lazy，只有在確定取用時才透過 repository 抓取並填入 Data Object。這對提升效能和減少資料庫查詢有幫助，因為未使用的資料不會主動載入。
  * **明確的資料結構：** 對團隊協作而言，Data Object 充當資源物件，明確列出資料結構，讓開發人員清楚每個 API 輸出的內容，增進可讀性和維護性。

* **缺點：**

  * **開發成本與重複定義：** 引入 DTO 意味著需要為每個模型撰寫對應的 Data class（如定義 `fromModel` 轉換方法等），增加開發量。某些情況下這可能導致與 Eloquent 模型欄位的重複定義。若模型屬性調整，DTO 也需同步修改，增加維護負擔。
  * **放棄部分 Eloquent 特性：** 一旦在 Repository 層將 Eloquent 模型轉成自訂 Data 對象，上層業務代碼將無法使用 Eloquent 給予的便利功能。例如，無法再直接使用延遲加載 (`$model->relation`) 或 Eloquent 提供的資料庫操作方法。如果日後需要取得關聯資料，必須提早在 Repository 抓取或透過額外的方法取得，這可能增加實作難度。正如參考文章所指出：「如果返回自定义的对象并且在上层逻辑中不再使用 Eloquent…这会让你不能使用 Laravel 中很多重要的功能」。
  * **實用性存疑：** Laravel 本身提供了資源 (Resource) 類別和 Eloquent 的隱藏屬性/關聯機制，可實現類似的輸出控制。對於許多一般場景，直接使用模型或 Resource 輸出 JSON 即可滿足需求。如果 DTO 沒有提供顯著的收益（例如沒有特別複雜的資料轉換邏輯），那麼引入 DTO 可能只是額外的層，讓架構更繁瑣。尤其在**以整合測試為主**的開發中，如果上層不關注資料細節，只做HTTP請求驗收結果，DTO 的價值會降低。

**何時需要 Data Object?** 如果您的專案需要嚴格區分資料層與業務層、避免直接使用 Eloquent 模型（例如採用領域驅動設計，強調模型與資料庫解耦），或需要統一多種資料來源的輸出格式（例如組合資料庫與第三方 API 回傳的資料），那麼 Data Object 是有價值的。在這些情況下，DTO 作為**抗腐層**可隔離不同來源資料，並提供穩定的資料介面。

然而，在一般的 Web 開發中，**Data Object 並非絕對必要**。如果您的輸出與資料庫模型基本一致，或Laravel 提供的 Resource/模型轉陣列已足夠使用，那麼可以減少 DTO 的使用範圍。尤其對於**簡單的資料流程**（例如直接回傳 `$model->toArray()` 或使用 `$request->user()` 取得當前使用者），直接使用模型可能更簡潔。總而言之，**權衡點**在於：DTO 帶來的資料保證與結構清晰度，是否值得其實現與維護成本。

## Repository 模式會不會過度設計？

在 Laravel 社區中，**是否使用 Repository 層**是爭論不休的話題。Repository 模式的初衷是將資料存取邏輯與商業邏輯分離，提供一個抽象層來封裝資料庫或其他外部存取。但在使用 Eloquent 的 Laravel 應用中，引入 Repository 層常被質疑是「多此一舉」，甚至官方中文社區也建議**不要過度使用 Repository**。讓我們分析 Repository 的利弊：

* **Repository 的潛在優點：**

  * **資料存取抽象化：** Repository 可以作為資料庫、第三方 API、檔案存儲（如 S3/CloudFront）等不同資料來源的統一介面。使用者只需透過 Repository 提供的方法取得資料，不需要關心其背後來自哪裡。這對於**多模組共用資料**很有幫助，例如核心模組提供 `MemberRepository`，其他功能模組透過它存取會員資料，而不直接耦合到 Eloquent 模型或外部服務。
  * **維護性與擴充性：** 當資料來源或 ORM 需要替換/升級時，可以只修改 Repository 層而不影響上層業務邏輯。例如將 Eloquent 換成其他 ORM、或改從外部服務讀取，控制在 Repository 內部調整即可。對**大型專案**而言，這種封裝提升了長期維護的可控性。
  * **統一的資料操作規範：** 在大型團隊中，使用 Repository 可以制定統一的資料存取接口和命名，避免每個人各自為政直接寫原生查詢或 Eloquent 語法。Repository 方法名稱通常基於**用例**（如 `findActiveMembers()`），清晰表達意圖，比隨處散落的查詢條件更易懂。同時能將**重複查詢邏輯**集中管理，減少程式碼重複。
  * **便於單元測試：** Repository 作為資料訪問抽象，可以注入 Mock 以模擬資料庫操作，在不連接真實資料庫的情況下測試業務邏輯。對需要嚴格單元測試的項目，這是很大的優點。然而，需注意您的專案目前**主要以 HTTP 測試為主**，這種整合測試方式直接測試整個請求流程，往往會使用實際的資料庫，因此可能並未充分利用 Repository 可替換的特性。

* **Repository 的缺點與過度設計之處：**

  * **抽象意義不大的封裝：** 在很多 Laravel 專案中，Repository 不過是對 Eloquent *Active Record* 的簡單包裝。例如提供 `find($id)`、`all()` 這類直接呼叫模型方法的函式，並沒有增加新的抽象層次或邏輯。正如某些開發者所批評的，如果 Repository 層僅僅返回 Eloquent 模型，那上層其實仍與 ORM 耦合，這樣的封裝幾乎沒有意義。Laravel 官方中文文檔甚至明確指出：「絕不使用 Repository，因為我們不是在寫 Java 代码，太多封装就成了過度設計 (Over Designed)，極大降低了编码愉悦感，使用 MVC 夠傻夠简单」。可見，過度強調模式反而可能讓開發失去效率和樂趣。
  * **增加額外的樣板程式碼：** 為每個模型建立 Repository 介面與實作，且方法多為一行呼叫，會導致大量重複和樣板代碼。如範例所示，`MembershipService->updateMemberActiveToken()` 僅呼叫 Repository 做更新，Service 並未增加額外邏輯。這類**“傳話筒”式**的 Service/Repository，讓整體架構顯得冗贅。團隊成員需要在多個文件間跳轉追蹤一個簡單操作，不利於開發維護。
  * **延遲了業務邏輯所在的位置：** Repository 模式要求將**所有業務無關**的資料操作下沉，但有時判斷某段邏輯屬於業務或資料並非那麼明確。例如在 Repository 中加入 `getAdults()` 這樣帶業務條件的查詢就違背了純資料存取的原則。雖然可以選擇全部業務條件都放在 Service，但如果 Service 只是簡單組合查詢條件，也可能質疑其存在價值。因此，不慎的分層會讓開發者混淆應該在哪一層實現某段邏輯，增加心智負擔。

**總的來說，Laravel 中使用 Repository 需要謹慎**。如果只是為了「分層」而分層，沒有真正提供更好的抽象，那就是過度設計。尤其當專案規模尚可、團隊熟悉 Eloquent，用 ActiveRecord 直接操作模型既快速又清晰時，引入 Repository 反而可能降低效率。在您的案例中，由於**多數測試為整合測試**、**團隊需要快速開發**且**模組之間可以直接共享核心模型**，Repository 的收益可能不足以抵消其負擔。正如引用文章的建議，小型應用甚至不需要 Service 層，查詢寫在模型即可；較複雜的專案則應加入 Service 處理業務，但 Repository 是否引入要根據需求決定。換言之，如果沒有明確的用途（如支援多資料源、很複雜的查詢封裝等），可以**不強制使用 Repository** 或僅在需要時使用。

## 根據專案情境的平衡架構建議

根據您提供的專案條件與上述分析，我們建議採取**彈性分層的架構設計**，在維持程式可讀性與可維護性的同時，避免不必要的複雜度。在實踐中，可以考慮以下平衡做法：

1. **Service 層聚焦業務邏輯，避免純粹轉調：** 保留 Service 層作為粗粒度的**用例**（Use Case）實現者，但僅在有實質**業務邏輯或流程**時才撰寫對應方法。如果某個 Service 方法只是簡單呼叫 Repository 或模型，且不增加任何額外行為，可以考慮省略該 Service 方法，直接在 Controller 調用 Repository/模型，減少一層呼叫。舉例而言，像 `MembershipService->updateMemberActiveToken()` 這種僅封裝一行更新操作的情況，可以讓 Controller 直接呼叫 `MemberRepository->updateActiveToken()` 或甚至直接對 Eloquent 模型操作，使程式更直觀。Service 應更多地用於**編排多個資料來源**或封裝複雜業務規則，而非每個 CRUD 都機械式地建立對應方法。

2. **Repository 層按需使用，優先考慮 Eloquent 直效方案：** 不必為每個 Eloquent 模型都建立 Repository。如果某些資料操作透過 Eloquent 已經能簡潔表達（例如 `$user = User::find($id)` 或 `$request->user()->tokens()->delete()`），團隊也熟悉其用法，那直接使用模型即可完成工作，沒有必要再繞一層。尤其像 `$request->user()` 這類 Laravel 提供的快捷方法，本質上已經是框架對資料存取的封裝，直接使用可提升開發效率。在需要**跨多來源**或**封裝複雜查詢**時，再為相關領域建立 Repository。例如，檔案上傳/下載可實作 `StorageRepository` 封裝 S3 和 CloudFront 的交互；又或者 `MemberRepository` 統一封裝會員相關的資料庫查詢和緩存讀取。確保 Repository 的方法命名語意清晰、符合業務場景（例如 `findActiveMembersByRole($role)`），並**返回適當的資料結構**（Eloquent 模型或 Data Object）。同時，謹記不要在 Repository 中實現與資料存取無關的業務邏輯，以保持分層的純粹性。如果團隊選擇不普遍使用 Repository，可以利用 **Eloquent Scope**、**Trait** 等替代方案來重用查詢條件，達到類似封裝效果。

3. **Data Object 用於輸出邊界或關鍵場景：** 可以採取**選擇性使用 DTO**的策略。在資料最終輸出（例如 API Response）或模組間資料傳遞的邊界處，使用 Data Object 提供穩定的結構。例如核心模組定義 `MemberData` DTO，統一規範會員資訊的結構，由各功能模組在需要回傳會員資料時使用它，確保格式一致。而在系統內部流程中（例如 Service 調用 Repository、一系列業務計算），可以直接使用 Eloquent 模型或原始資料結構，以減少轉換開銷。如果擔心 Eloquent 模型在不同模組中傳遞可能被不當修改，可以考慮在需要時將模型轉成純 PHP 陣列或標準物件，作為**只讀資料**使用，而不是硬性要求處處皆 DTO。這樣既保留了 DTO 在輸出階段的優點，也避免在每個處理步驟都進行資料封裝/拆封。

4. **保持架構一致性並撰寫清晰註解：** 在允許彈性使用的同時，要避免團隊各自為政導致的混亂。建議制定一份簡要的**約定**：何種情況使用 Repository，何時直接使用模型，何時應該轉換 DTO。例如：

   * Controller 層**優先**使用 Service 方法處理複雜操作，但對於簡單的查詢或框架提供的方法（如認證相關的 `$request->user()`），可直接使用模型或 Laravel 特定解決方案。
   * Service 層**可以**直接使用 Eloquent 模型進行資料庫操作（如建立、查詢、更新），除非該操作被多處重複使用或有切換資料源需求，再提取到 Repository 實現。
   * Repository 層**只在需要**時引入。例如當某模型相關的查詢遍布各處且可能演變，或需要串接其他系統時，才封裝為 Repository。否則，可由 Service 或模型本身（使用靜態方法或 Scope）處理。
   * Data Object **主要用於** API 回應封裝或特定需要嚴格資料結構的場景。普通的內部資料傳遞可不必處處轉換，以免降低開發速度。

   同時，為了協調團隊，每個選擇的背後請**撰寫註解或說明**，讓同事了解為何此處直用模型、彼處用 Repository。清晰的註解與文件能減少誤解，使彈性的架構運行良好。

5. **定期檢視與調整：** 最後，架構並非一成不變。隨著專案擴大或需求改變，定期回顧當前分層是否仍適用。若發現某部分代碼邏輯越來越複雜、被多處複用，那就考慮將其下沉到 Service 或 Repository 重構。反之，如果某層抽象阻礙了開發效率且收益不大，可以適當簡化。保持彈性心態，根據實際情況調整，才能既避免過度設計又不失架構的井然有序。

## 結論

在 Laravel 大型專案中找到架構的平衡點，需要在**開發便利**與**長期維護**間作出權衡。引入 Service、Repository、Data Object 等模式本身沒有對錯，關鍵在於是否解決了實際問題。如果感到這些層使開發變慢、代碼重複，那就說明可能出現了過度設計，需要適當簡化。根據提供的情境，我們建議：**以 Service 層承載業務，用 Repository 封裝必要的資料存取，用 DTO 規範輸出，**但切勿僵化遵循模式。允許直接使用 `$request->user()` 等 Laravel 提供的簡化設計，在保證代碼可讀性的前提下採用最直接明瞭的方案。正如社群經驗所示，過多的封裝會降低開發樂趣與效率；因此，讓架構為需求服務，在複雜度和簡潔度之間取得動態平衡，才是最合理的方向和建議。祝您的專案在適合的架構下順利發展！
